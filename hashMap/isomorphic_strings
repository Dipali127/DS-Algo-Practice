// Leetcode Problem (Isomorphic Strings)

// Note:
// The rule says: "No two different characters may map to the same character,
// but a character is allowed to map to itself."

// Example:
// s = "badc", t = "baba"
// - 'b' → 'b'
// - 'a' → 'a'
// - 'd' → 'b'   <-- conflict (because 'b' is already mapped by 'b')
// This violates the rule: two different characters ('b' and 'd') map to the same 'b'.

// However, a character mapping to itself is allowed.
// Example: 'b' → 'b' is valid.

// Approach:
// Use two maps:
// 1. mapS: maps characters from s → t
// 2. mapT: maps characters from t → s
//
// These maps ensure that:
// - No two different characters in s map to the same character in t.
// - No two different characters in t map to the same character in s.
//
// For each index i:
// - If s[i] has been mapped before, check if it still maps to t[i].
// - If t[i] has been mapped before, check if it still maps to s[i].
// - If any mismatch occurs, return false.
// - Otherwise, store the mapping in both maps.
//
// After full traversal with no conflicts, the strings are isomorphic.
//
// Time Complexity: O(N)
// We traverse the strings once and perform O(1) map operations per character.
//
// Space Complexity: O(N)
// In the worst case, the maps store all unique characters of the strings.



var isIsomorphic = function (s, t) {

    mapS = new Map();
    mapT = new Map();
    for (let i = 0; i < s.length; i++) {
        if (!mapS.has(s[i])) {
            mapS.set(s[i], t[i]);
        } else {
            if (mapS.get(s[i]) !== t[i]) {
                return false;
            }
        }

        if (!mapT.has(t[i])) {
            mapT.set(t[i], s[i]);
        } else {
            if (mapT.get(t[i]) !== s[i]) {
                return false;
            }
        }
    }
    return true;
};