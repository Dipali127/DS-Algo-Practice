// Leetcode Problem:
// Brute force approach:
// approach:
// use of nested loop where the outer loop iterates through each element of the array.
// the inner loop checks if the current element (pointed by the outer loop) is equal to any other 
// element (pointed by the inner loop) within a distance ùëò.
// TC: O(N^2), because of the nested loop. 
// SC: O(1) , as there is no extra space used.

var containsNearbyDuplicate = function (arr, k) {
  for (let i = 0; i < arr.length - 1; i++) {
      for (let j = i + 1; j < arr.length; j++) {
          if (arr[i] === arr[j] && Math.abs(i - j) <= k) {
              return true;
          }
      }
  }
  return false;
};

// Optimal approach: Using a Hash Set
// 
// Approach:
// - I will use a Hash Set to store up to 'k' elements.
// - Traverse through the given array 'nums', and while iterating, check if the Hash Set already contains
//    the current element.
//     - If it does, return true immediately (a duplicate within distance 'k' is found).
// - Otherwise, add the current element to the Hash Set.
//     - Meanwhile, if the size of the Hash Set exceeds 'k', remove the earliest (oldest) element from 
//      the set ‚Äî i.e., the element at index (i - k).
// - After the traversal, if no such duplicate is found, return false.
//
// Time Complexity: O(N), where N is the length of the array, as each element is processed once.
// Space Complexity: O(min(N, k)), because the Hash Set stores at most 'k' elements at any time.
//     If k is smaller than or equal to N, the Hash Set will store up to k elements,
//     since older elements are removed once the window size exceeds k.


var containsNearbyDuplicate = function(nums, k) {
    let set = new Set();

    for (let i = 0; i < nums.length; i++) {
        if (set.has(nums[i])) return true;

        set.add(nums[i]);
        if (set.size > k) {
            set.delete(nums[i - k]);
        }
    }

    return false;
}
