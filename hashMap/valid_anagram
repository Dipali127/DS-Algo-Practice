// Leetcode Problem:
// brute force approach:
// approach:
// convert both strings into arrays of characters.
// sort the arrays in ascending order.
// join the sorted arrays back into strings.
// compare the sorted strings using the strict equality operator.
// the strict equality operator first checks if the lengths of both strings are equal. 
// if not, it returns false. If lengths are equal, it compares both strings character by character
// until it reaches the end of the string or finds any differing character. 
// if a difference is found, it returns false; otherwise, it returns true.
// TC: O(NlogN), Explanation:
// O(N) for converting each string into an array.
// O(N log N) for sorting each array.
// O(N) for joining each array back into a string.
// overall TC: O(N) + O(N log N) + O(N) = O(N log N), as sorting is the most expensive operation.
// SC: O(N),  due to the additional space required for the arrays created by `split` and for the intermediate sorted arrays.

 var isAnagram = function(s, t) {
    s = s.split('').sort().join('');
    t = t.split('').sort().join('');

   return s === t;
 }

// Optimal approach:
// approach:
// check if the lengths of strings s and t are not equal. if they are not, return false.
// use a Map to store the count of each character in string s.
// traverse string t and check if each character exists in the Map with a count greater than 0.
// if it does, decrement the count in the Map.
// if it does not exist or the count is 0, return false.
// finally, check if all counts in the Map are zero. if any count is not zero, return false.
// TC: O(N), explanation:
// O(N) to store each character's count in the Map from string s.
// O(N) to check each character of string t in the Map and update counts.
// overall TC: O(N) + O(N) = O(2N) = O(N).
// SC: O(N), as the Map is used to store all characters of string s.

var isAnagram = function (s, t) {
    if (s.length !== t.length) {
        return false;
    }
    let map = new Map();
    for (let i = 0; i < s.length; i++) {
        if (!map.has(s[i])) {
            map.set(s[i], 1);
        } else {
            map.set(s[i], map.get(s[i]) + 1);
        }
    }

    for (let i = 0; i < t.length; i++) {
        if (!map.has(t[i]) || map.get(t[i]) === 0) {
            return false;
        } else {
            map.set(t[i], map.get(t[i]) - 1);
        }
    }

    return true;
}
