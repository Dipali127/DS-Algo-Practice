// Leetcode Problem:
// problem statement: given an array 'height' representing the heights of the container walls,
// find the maximum area of water that the container can hold.

// brute force approach:
// approach:
// use nested loops to calculate the area for every possible pair of container walls.
// iterate over each element in the array using two nested loops.
// for each pair of elements, calculate the minimum height between the two elements
// (since the water can only be held up to the shorter wall).
// calculate the width (distance) between the two walls.
// calculate the area using the formula: area = minHeight * width.
// keep track of the maximum area found during the iteration.
// once all possible areas are calculated, return the maximum area that can contain the most water.

// Note: the reason for taking the minimum height between the two walls is that water can only be held
// up to the height of the shorter wall to prevent overflow.
// TC: O(N^2) - due to the use of nested loops to find the area for each possible pair.
// SC: O(1) - no additional space is used apart from the variable 'maxArea'.

var maxArea = function (height) {
    let maxArea = 0;
    for (let i = 0; i < height.length - 1; i++) {
        for (let j = i + 1; j < height.length; j++) {
            let minH = Math.min(height[i], height[j]);
            let width = j - i;
            let currArea = minH * width;
            maxArea = Math.max(maxArea, currArea);
        }
    }
    return maxArea;
};


// optimal approach: use of two pointers
// the brute force approach is not efficient due to its time complexity of O(n^2), as it involves checking
// every possible pair of container walls. the two-pointer approach improves the time complexity to O(n).
// the intention behind the two-pointer approach is to avoid unnecessary comparisons of smaller heights.
// approach:
// initialize maxArea to 0, which will contain the maximum amount of water that the container can hold.
// initialize two pointers, one at the beginning (left) and one at the end (right) of the array.
// iterate until the two pointers meet.
// while iterating:
// find the minimum height between the two pointers.
// calculate the width (distance) between the two pointers.
// calculate the current area using the formula: area = minHeight * width.
// update the maximum area if the current area is larger.
// move the pointer pointing to the shorter wall towards the center.
// return the maximum area found.
// TC: O(N), as we traverse the given height array using two pointers in a single pass.
// SC: O(1), as no additional space is used apart from maxArea.

var maxArea = function(height) {
    let maxArea = 0; 
    let left = 0, right = height.length - 1;

    while (left < right) { 
        let minHeight = Math.min(height[left], height[right]); 
        let width = right - left; 
        let currentArea = minHeight * width; 
        maxArea = Math.max(maxArea, currentArea); 
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return maxArea; 
};

