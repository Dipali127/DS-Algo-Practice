// Leetcode Problem:
// problem statement: given an array 'height' representing the heights of the container walls,
// find the maximum area of water that the container can hold.

// brute force approach:
// approach:
// use nested loops to calculate the area for every possible pair of container walls.
// iterate over each element in the array using two nested loops.
// for each pair of elements, calculate the minimum height between the two elements
// (since water only store upto the minimum height of container).
// calculate the width (distance) between the two walls.
// calculate the area using the formula: area = minHeight * width.
// keep track of the maximum area found during the iteration.
// once all possible areas are calculated, return the maximum area that can contain the most water.

// Note: the reason for taking the minimum height between the two walls is that water can only be held
// up to the height of the shorter wall to prevent overflow.
// TC: O(N^2) - due to the use of nested loops to find the area for each possible pair.
// SC: O(1) - no additional space is used apart from the variable 'maxArea'.

var maxArea = function (height) {
    let maxArea = 0;
    for (let i = 0; i < height.length - 1; i++) {
        for (let j = i + 1; j < height.length; j++) {
            let minH = Math.min(height[i], height[j]);
            let width = j - i;
            let currArea = minH * width;
            maxArea = Math.max(maxArea, currArea);
        }
    }
    return maxArea;
};


// optimal approach: use of two pointers
// approach:
// instead of considering each possible pairs of container wall which increases the time complexity.
// i will use of the two-pointer approach where low points to the 0rth index of the array height and high points to the
// last index of the height array.
// the idea behind using two-pointer approach is to avoid unnecessary comparisons of smaller heights since they give a smaller area.
// i will run a while loop until left is less than right and in each iteration, i will find the area between pair of container wall and 
// Update maxArea if the new area is greater the maxArea,
//  and check if height of wall pointed by left pointer is less than the height of wall pointed by right 
// pointer, if it is then i will increment the left pointer to avoid minimum height (since minimum height give minimum area).
// but if height of wall pointed by left pointer is greater than the height of wall pointed by right pointer,then decrement
// right pointer.
// once left is greater than right, while loop break and return maxArea.
// TC: O(N), as we traverse the given height array using two pointers in a single pass.
// SC: O(1), as no additional space is used apart from maxArea.

var maxArea = function(height) {
    let maxArea = 0; 
    let left = 0, right = height.length - 1;

    while (left < right) { 
        let minHeight = Math.min(height[left], height[right]); 
        let width = right - left; 
        let currentArea = minHeight * width; 
        maxArea = Math.max(maxArea, currentArea); 
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return maxArea; 
};

