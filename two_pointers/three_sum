// Leetcode Problem:
// Brute force approach:
// I will consider each possible triplet using three nested loops, and for each triplet, I will compute the sum of its elements and check if the computed sum equals zero. If it does, I will ensure the triplet is unique by verifying that it doesn’t already exist in the set.

// To ensure the triplet doesn’t exist in the set, I will sort the triplet to maintain ordering. To avoid storing duplicate triplets, I will check if the current triplet doesn’t already exist. If it doesn’t, I will store it in the result array. If it does exist in the set, it means the current triplet is a duplicate.
// TC:- O(N^3), because of triply nested loop.
// SC:- O(N), to store the triplets in set.

var threeSum = function(nums) {
    let result = [];
    let set = new Set();
  for(let i = 0; i < nums.length-2; i++){
    for(let j = i+1; j < nums.length-1; j++){
        for(let k = j+1; k < nums.length; k++){
            if(nums[i] + nums[j] + nums[k] === 0){
                let tripletSort = [nums[i], nums[j], nums[k]].sort((a,b) => a - b);
                let tripletStr = tripletSort.join(',');
                if(!set.has(tripletStr)){
                    set.add(tripletStr);
                    result.push(tripletSort);
                }
            }   
        }
    }
  }
  return result;  
};

// Optimal approach: using three pointers
// Approach:
// I will sort the array to apply the three-pointer technique for finding triplets and avoiding duplicates. I will iterate through the array to find valid triplets.

// In the outer loop, I will check if the current element is the same as the previous one. If it is, I will skip it to avoid duplicate triplets. For each element, I will set two pointers:

// start will point to the next element of the current element.
// end will point to the last element.
// I will run a while loop until start is less than end to check for triplets where the sum is zero.

// If the sum of the triplet is zero, I will add it to the result array and then move both pointers (start and end).
// I will also skip any duplicate values for the start and end pointers to avoid duplicates in the result.
// If the sum of the triplet is less than zero, I will move the start pointer to the right to increase the sum.
// If the sum is greater than zero, I will move the end pointer to the left to decrease the sum.
// Finally, I will return the result array containing all unique triplets.

var threeSum = function (nums) {
    nums.sort((a,b) => a-b), result = [];
    for (let i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
            let start = i + 1, end = nums.length - 1
            while (start < end) {
                if (nums[i] + nums[start] + nums[end] === 0) {
                    result.push([nums[i], nums[start], nums[end]]);
                    start++;
                    end--;

                    while (start < end && nums[start] === nums[start - 1]) {
                        start++;
                    }

                    while (start < end && nums[end] === nums[end + 1]) {
                        end--;
                    }
                }else if(nums[i] + nums[start] + nums[end] < 0){
                    start++;
                }else{
                    end--;
                }

            }
        }
    return result;
}