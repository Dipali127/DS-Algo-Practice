// Leetcode Problem: 15
// Brute force approach:
// I will consider each possible triplet using three nested loops, and for each triplet,
// I will compute the sum of its elements and check if the computed sum equals zero.
// If it does, I will ensure the triplet is unique by verifying that it doesn’t already exist in the set.
// To ensure the triplet doesn’t exist in the set, I will sort the triplet to maintain ordering.
// Then, I will convert the triplet into a string separated by commas and add it to the set.
// If the triplet string is not already in the set, I will add it to the result array.
// If it does exist in the set, it means the current triplet is a duplicate.
// TC: O(N^3), due to the triply nested loop.
// SC: O(N), to store the triplets in the set.

var threeSum = function(nums) {
    let result = [];
    let set = new Set();
  for(let i = 0; i < nums.length-2; i++){
    for(let j = i+1; j < nums.length-1; j++){
        for(let k = j+1; k < nums.length; k++){
            if(nums[i] + nums[j] + nums[k] === 0){
                let tripletSort = [nums[i], nums[j], nums[k]].sort((a,b) => a - b);
                let tripletStr = tripletSort.join(',');
                if(!set.has(tripletStr)){
                    set.add(tripletStr);
                    result.push(tripletSort);
                }
            }   
        }
    }
  }
  return result;  
};

// Optimal approach: using three pointers
// Approach:
// Leetcode Problem: 15

// Brute force approach:
// I will consider each possible triplet using three nested loops, and for each triplet,
// I will compute the sum of its elements and check if the computed sum equals zero.
// If it does, I will ensure the triplet is unique by verifying that it doesn’t already exist in the set.
// To ensure the triplet doesn’t exist in the set, I will sort the triplet to maintain ordering.
// Then, I will convert the triplet into a string separated by commas and add it to the set.
// If the triplet string is not already in the set, I will add it to the result array.
// If it does exist in the set, it means the current triplet is a duplicate.
// TC: O(N^3), due to the triply nested loop.
// SC: O(N), to store the triplets in the set.


// Optimal approach: using three pointers
// Approach:
// I will sort the array to apply the three-pointer technique for finding triplets and avoiding duplicates.
// I will iterate through the array to find valid triplets.
// In the outer loop, I will check if the current element is the same as the previous one.
// If it is, I will skip it to avoid duplicate triplets.
// For each unique element, I will set two pointers:
// - start pointer will point to the next element after the current element (i + 1)
// - end pointer will point to the last element of the array.
// I will run a while loop until start is less than end to check for triplets where the sum is zero.
// If the sum of the triplet is zero, I will add it to the result array and move both pointers inward.
// After moving the pointers, I will skip any duplicate values to avoid duplicate triplets in the result.
// If the sum of the triplet is less than zero, I will move the start pointer to the right to increase the sum.
// If the sum is greater than zero, I will move the end pointer to the left to decrease the sum.
// Finally, I will return the result array containing all unique triplets.


var threeSum = function (nums) {
    nums.sort((a,b) => a-b), result = [];
    for (let i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
            let start = i + 1, end = nums.length - 1
            while (start < end) {
                if (nums[i] + nums[start] + nums[end] === 0) {
                    result.push([nums[i], nums[start], nums[end]]);
                    start++;
                    end--;

                    while (start < end && nums[start] === nums[start - 1]) {
                        start++;
                    }

                    while (start < end && nums[end] === nums[end + 1]) {
                        end--;
                    }
                }else if(nums[i] + nums[start] + nums[end] < 0){
                    start++;
                }else{
                    end--;
                }

            }
        }
    return result;
}