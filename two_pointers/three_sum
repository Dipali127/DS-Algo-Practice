// Leetcode Problem: 15
// Brute-force approach:
// Approach:
// I will use a result array to store unique triplets and a hash set to quickly check 
// whether a triplet already exists in it, so that I can avoid adding duplicate triplets to the result array.
// I will consider every possible triplet using three nested loops, and for each triplet,
// I will compute the sum of its elements and check if the computed sum equals zero.
// If it does, I will ensure the triplet is unique by verifying that it doesn’t already exist in the set.
// To achieve this, I will first sort the triplet to maintain a consistent order so that only unique triplets are stored,
// and then convert the sorted triplet into a string so that I can easily check whether the current triplet is already 
// in the hash set.
// If the triplet string is not already in the hash set, I will add it to the result array.
// If it does exist in the set, it means the current triplet is a duplicate and should be skipped.
// Time Complexity: O(N^3), due to the triple nested loop.
// Space Complexity: O(N), to store the triplets in the hash set.

// Why are we converting the sorted array into a string instead of directly storing it as an array?
// If we store the sorted array directly in a hash set, JavaScript compares arrays by reference,
// not by value.
// So even if [1,2,3] already exists in the set, when we try to insert another [1,2,3], the comparison will return false 
// because they are two different array objects in memory (different references).
// That’s why we convert the sorted array into a string. Unlike arrays, JavaScript compares strings by value, 
// so '1,2,3' and another '1,2,3' are considered equal, which allows the set to properly detect duplicates.
// Note: when creating [nums[i], nums[j], nums[k]] before sorting, a new array reference (address) is created in memory.

var threeSum = function(nums) {
  let set = new Set();
  let result = [];
  for(let i = 0; i <= nums.length-3; i++){
    for(let j = i+1; j <= nums.length-2; j++){
      for(let k = j+1; k < nums.length; k++){
        if(nums[i] + nums[j] + nums[k] === 0){
          let triplet = [nums[i] , nums[j], nums[k]].sort((a,b) => a-b);
          let key = triplet.toString();
          if(!set.has(key)){
            set.add(key);
            result.push(triplet);
          }
        }
      }
    }
  }
  
  return result;
}


// Optimal approach: using two pointers (after sorting)
// Approach:
// I will sort the array to apply the two-pointer technique for finding triplets and avoiding duplicates.
// I will iterate through the array to find valid triplets.
// In the outer loop, I will check if the current element is the same as the previous one.
// If it is, I will skip it to avoid duplicate triplets.
// For each unique element, I will set two pointers:
// - start pointer will point to the next element after the current element (i + 1)
// - end pointer will point to the last element of the array.
// I will run a while loop until start is less than end to check for triplets where the sum is zero.
// If the sum of the triplet is zero, I will add it to the result array and move both pointers inward (start++ and end--).
// After updating the pointers, I will use two while loops to skip any duplicate values at the start and end positions 
// to ensure we don’t process the same number multiple times and add duplicate triplets.
// If the sum of the triplet is less than zero, I will move the start pointer to the right to increase the sum.
// If the sum is greater than zero, I will move the end pointer to the left to decrease the sum.
// Finally, I will return the result array containing all unique triplets.
// Time Complexity: O(N^2), Explanation: 
// Sorting the array takes O(N log N) time.
// and the two-pointer technique runs in O(N^2) time in the 
// worst case, since i have use nested loop where outer loop runs through each element and inner loop 
// both pointers run through each element at most once.
// Space Complexity: O(1), Since we haven't use any extra space apart from few pointers.

var threeSum = function (nums) {
    nums.sort((a,b) => a-b), result = [];
    for (let i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
            let start = i + 1, end = nums.length - 1
            while (start < end) {
                if (nums[i] + nums[start] + nums[end] === 0) {
                    result.push([nums[i], nums[start], nums[end]]);
                    start++;
                    end--;

                    while (start < end && nums[start] === nums[start - 1]) {
                        start++;
                    }

                    while (start < end && nums[end] === nums[end + 1]) {
                        end--;
                    }
                }else if(nums[i] + nums[start] + nums[end] < 0){
                    start++;
                }else{
                    end--;
                }

            }
        }
    return result;
}