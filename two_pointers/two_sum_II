// Leetcode Problem:
// brute force approach:
// approach:
// use a nested loop where the outer loop considers each element and the inner loop sums it with all subsequent elements to check if the sum equals the target.
// if the sum equals the target, return the 1-based indices of the two elements, as the given array
// uses 1-based indexing, add 1 to both indices before returning.
// if no such pair is found after traversing the entire array, return -1.
// TC: o(N^2), due to the use of nested loops to check each pair of elements.
// SC: o(1), as there is no additional space used apart from the variables.

 var twoSum = function(arr,target){
     for(let i = 0;i<arr.length-1;i++){
         for(let j = i+1;j<arr.length;j++){
             if(arr[i]+arr[j]==target){
                 return [i+1,j+1];
             }
         }
     }
     return -1;
 }

// optimal approach: using two pointers
// approach:
// take two pointers, `i` and `j`. where `i` points to the start of the array and `j` points to the end of the array.
// use a while loop to traverse the array while `i` is less than `j`.
// inside the loop, check if the sum of the elements at the `i` and `j` pointers equals the target.
// if the sum equals the target, return the 1-based indices of these two elements.
// if the sum is less than the target, increment the `i` pointer to increase the sum (since the array is assumed to be sorted).
// if the sum is greater than the target, decrement the `j` pointer to decrease the sum.
// if no valid pair is found after the loop, return -1.
// TC: o(N), where N is the length of the array.  as the array is traversed in a single pass..
// SC: o(1), as there is no additional space used apart from the pointers.

var twoSum = function(arr, target) {
    let i = 0;
    let j = arr.length-1;
    while(i<j){
        if(arr[i]+arr[j]===target){
            return [i+1,j+1];
        }else if(arr[i]+arr[j]<target){
            i++;
        }else{
            j--;
        }
    }
    return -1;
};