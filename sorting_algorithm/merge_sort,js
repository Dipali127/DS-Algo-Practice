// merge sort is based on divide and conquer algorithm which recursively divide the array into subarray until the
// size of the array becomes one.
// once the size of the array becomes one, merge function merge the array until the array will be completely merge.
// TC:- O(NLOGN), as merge sort will take O(logN) complexity to divide the array into two halves and merge function
// will take O(N) complexity to sort the array.
// Worst,best and average case time complexity of merge sort is O(NlogN).
// Space Complexity:- O(N) for recursively dividing the array and O(N) for
// extra space used to hold the left and right subarrays during the merging process.
// So, overall SC:- O(N) + O(N) = O(N).

let arr=[4,3,9,7,6,8];
let low = 0, high = arr.length-1;
console.log(mergeSort(arr, low, high));
function mergeSort(arr, low, high){
    if(low < high){
        let mid = Math.floor(low + (high - low)/2);
        mergeSort(arr, low, mid);
        mergeSort(arr, mid+1, high);
        merge(arr, low, mid, high);
    }
    
    return arr;
}

function merge(arr, low, mid, high){
    let l1 = mid - low + 1;
    let l2 = high - mid;
    
    let arr1 = new Array(l1);
    let arr2 = new Array(l2);
    
    for(let i = 0; i  < l1; i++){
        arr1[i] = arr[i+low];
    }
    
    for(let i = 0; i  < l2; i++){
        arr2[i] = arr[mid + i + 1];
    }
    
    let i = 0, j = 0, k = 0;
    let temp =  new Array();
    while(i < l1 && j < l2){
        if(arr1[i] <= arr2[j]){
            temp[k++] = arr1[i++];
        }else{
            temp[k++] = arr2[j++]
        }
    }
    
    while(i < l1){
        temp[k++] = arr1[i++]; 
    }
    
    while(j < l2){
        temp[k++] = arr2[j++];
    }
    
    let x = low;
    for(let i = 0; i < temp.length; i++){
        arr[low++] = temp[i];
    }
    
    return arr;
}