// GFG PROBLEM:
// we only can do transpose in a square matrix.
// approach:- swap the value which are below the diagonal with the value which are above 
// the diagonal and this will change the rows into colums and colums into rows.
// it means matrix[i][j] = matrix[j][i] and matrix[j][i] = matrix[i][j].
// here in below code, outer loop iterate through all the row of matrix and inner loop iterate  
// from start index of each row to less than diagonal value of that row.
// The outer loop runs from 0 to n-1, where n is the size of the matrix. This loop iterates
// n times.
// Inside the outer loop, there is another nested loop that runs from 0 to i-1. 
// Since this loop depends on the outer loop variable i, the number of iterations increases as
// i increases. On average, this loop runs approximately n/2 times.
// Within the inner loop, there are constant time operations: swapping two elements of the
// matrix. So, the total number of iterations can be approximated as the sum of the series:
// 1 + 2 + 3 + ... + n
// This is a triangular series, and the sum of the first n natural numbers is given by 
// n*(n+1)/2.
// Therefore, the total number of iterations is approximately (n*(n+1))/2. Since this is 
// proportional to n^2, the time complexity of the code is O(N^2) and SC:O(1).

class Solution {
    //Function to find transpose of a matrix.
    transpose(matrix, n)
    {
        for(let i=0;i<matrix.length;i++){
            for(let j=0;j<i;j++){
                let temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

// Leetcode Problem:- 867
// Optimal Approach:
// Approach:
// The problem does not guarantee that the matrix is square, so we must handle both square and non-square matrices.
// In the transpose of a matrix, we flip the matrix over its main diagonal (from top-left to bottom-right).
// This operation converts rows into columns and columns into rows. 
// For example, a 2x3 matrix becomes a 3x2 matrix after transposition.
// To achieve this, we create a new matrix (result), where the element at position matrix[i][j]
// in the original matrix is placed at position result[j][i] in the transposed matrix.
// Time Complexity: O(N*M)
// - We iterate through each element of the original matrix once,
//   where N is the number of rows and M is the number of columns.
// Space Complexity: O(N*M)
// - We use additional space to create a new 2D array (result) that holds the transposed matrix.

var transpose = function(matrix) {
    let row = matrix.length;
    let col = matrix[0].length;
    let result = [];

    for (let j = 0; j < col; j++) {
        let newRow = [];
        for (let i = 0; i < row; i++) {
            newRow.push(matrix[i][j]);
        }
        result.push(newRow);
    }

    return result;
};
