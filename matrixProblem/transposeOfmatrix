// GFG PROBLEM
// we only can do transpose in a square matrix.
// appraoch:- swap the value which are below the diagonal with the value which are above 
// the diagonal and this will change the rows into colums and colums into rows
// it means matrix[i][j] = matrix[j][i] and matrix[j][i] = matrix[i][j].
// here in below code, outer loop iterate through all the row of matrix and inner loop iterate  
// from start index of each row to less than diagonal value of that row.
// The outer loop runs from 0 to n-1, where n is the size of the matrix. This loop iterates
// n times.
//  Inside the outer loop, there is another nested loop that runs from 0 to i-1. 
// Since this loop depends on the outer loop variable i, the number of iterations increases as
// i increases. On average, this loop runs approximately n/2 times.
// Within the inner loop, there are constant time operations: swapping two elements of the
// matrix. So, the total number of iterations can be approximated as the sum of the series:
// 1 + 2 + 3 + ... + n
// This is a triangular series, and the sum of the first n natural numbers is given by 
// n*(n+1)/2.
// Therefore, the total number of iterations is approximately (n*(n+1))/2. Since this is 
// proportional to n^2, the time complexity of the code is O(N^2) and SC:O(1).

class Solution {
    //Function to find transpose of a matrix.
    transpose(matrix, n)
    {
        for(let i=0;i<matrix.length;i++){
            for(let j=0;j<i;j++){
                let temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}