// GFG PROBLEM:
// we only can do transpose in a square matrix.
// appraoch:- swap the value which are below the diagonal with the value which are above 
// the diagonal and this will change the rows into colums and colums into rows
// it means matrix[i][j] = matrix[j][i] and matrix[j][i] = matrix[i][j].
// here in below code, outer loop iterate through all the row of matrix and inner loop iterate  
// from start index of each row to less than diagonal value of that row.
// The outer loop runs from 0 to n-1, where n is the size of the matrix. This loop iterates
// n times.
//  Inside the outer loop, there is another nested loop that runs from 0 to i-1. 
// Since this loop depends on the outer loop variable i, the number of iterations increases as
// i increases. On average, this loop runs approximately n/2 times.
// Within the inner loop, there are constant time operations: swapping two elements of the
// matrix. So, the total number of iterations can be approximated as the sum of the series:
// 1 + 2 + 3 + ... + n
// This is a triangular series, and the sum of the first n natural numbers is given by 
// n*(n+1)/2.
// Therefore, the total number of iterations is approximately (n*(n+1))/2. Since this is 
// proportional to n^2, the time complexity of the code is O(N^2) and SC:O(1).

class Solution {
    //Function to find transpose of a matrix.
    transpose(matrix, n)
    {
        for(let i=0;i<matrix.length;i++){
            for(let j=0;j<i;j++){
                let temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

// Leetcode Problem:- 867
// Optimal Approach:
// approach:
// Since, the problem does not specify that the matrix is square, so we need to handle both square and non-square matrices. To achieve the transposition, we create a new matrix where the rows of the original matrix become columns in the transposed matrix and vice versa. This means the element at position matrix[i][j] in the original matrix will be placed at position transposeMatrix[j][i] in the transposed matrix.
// TC:- O(N*M), where N is the number of rows and M is the number of columns in the original matrix and We have to iterate over all elements of the original matrix.
// SC:- O(N*M), for the new 2D array (transposeMatrix), which has the same size as the original matrix.
// Note:- let transposeMatrix = Array.from({ length: n }, () => new Array(m)) here,This creates an array with n rows, and for each row, it creates an array with m columns. 

var transpose = function(matrix) {
    let m = matrix.length;
    let n = matrix[0].length;
    let transposeMatrix = Array.from({ length: n }, () => new Array(m));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            transposeMatrix[j][i] = matrix[i][j];  // Swap elements for transposition
        }
    }
 
    return transposeMatrix;
 };