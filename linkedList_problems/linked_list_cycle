// Leetcode Problem:
// brute force approach:-
// i will use of a set to store the address (the whole object) of a node in hash set.
// then i will traverse through the linked list until found that node of a linked list which is already 
// in set.
// once i found a case where the current iterated node is already exist in the set then return true
// immediately otherwise return false.
// TC: O(N) to iterated through the linked list.
// SC: O(N) to store all the values of linked list in set.

 var hasCycle = function(head){
    let temp = head;
    let set = new Set();
    while(temp!=null){
        if(set.has(temp)){
            return true;
        }else{
            set.add(temp);
        }

        temp = temp.next;
    }

    return false;
 }

// optimal appraoch:- use of floyd's cylce finding algortihm also known as the Tortoise and Hare algorithm
// which uses two pointers slow and fast where slow pointer move one step at a time and fast pointer move twice as fast 
// as slow.
// i will run a while loop until the fast pointer is not equal to null or fast.next is not equal to null
// inside the loop, first i will move slow pointer to its next and fast pointer move to twice as fast as slow,
// meanwhile i will check if both slow and fast pointer point to same node, if it is then i will return true immediately 
// otherwise after processing through each node if i haven't found any cycle then i will return false. 
// TC: O(N) to traverse all the nodes in the list to detect a cycle.
// SC: O(1) as we uses a constant amount of extra space for the two pointers (fast and slow).

var hasCycle = function(head) {
    let fast = head ,slow = head;
    while(fast!=null  && fast.next!=null){
        slow=slow.next;
        fast=fast.next.next;
        
        if(slow==fast){
            return true;
        }
    }

    return false;
};