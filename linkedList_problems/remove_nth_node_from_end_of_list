// Brute Force Approach:
// 1. Since we cannot directly traverse from the end, calculate the length of the linked list.
// 2. If length == n, that means we need to delete the head node, so return head.next.
// 3. Otherwise, calculate the position of the node just before the node to be deleted: (length - n).
// 4. Traverse to that node and update its next pointer to skip the nth node from the end.
//
// Time Complexity: O(N)
//   - O(N) to calculate length
//   - O(N) in worst case to traverse again till the position before the deleted node
//   - Worst case: if n = 1 (deleting last node), second loop runs almost till the end → O(N)
//   - Best case: if n = length (deleting head node), second loop doesn’t run at all → O(N)
//   - Overall: O(N)
// Space Complexity: O(1), only constant extra space is used.

var removeNthFromEnd = function(head, n) {
    let length = 0;
    let temp = head;
    while(temp !== null){
        length++;
        temp = temp.next;
    }

    if(n === length){
        return head.next;
    }

    let itrt = 1;
    let current = head;
    while(itrt < length - n){
        current = current.next;
        itrt++;
    }

    current.next = current.next.next;
    return head;
};


// Optimal Approach (Two Pointers - Slow & Fast):
// 1. Initialize two pointers (slow and fast) at head.
// 2. Move the fast pointer n steps ahead to create a gap of n nodes between slow and fast.
//    This ensures that when fast reaches the end of the list, slow will be positioned
//    just before the node that needs to be deleted.
//    We use this approach because the length of the linked list is unknown.
// 3. If fast becomes null, then head is to be deleted → return head.next.
// 4. Otherwise, move both slow and fast one step at a time until fast reaches the end.
// 5. Slow will now be at the node just before the one to be deleted. Update slow.next.
//
// Time Complexity: O(N)
//   - O(N) to move fast pointer n steps initially
//   - O(N) in worst case to move both fast and slow until end
//   - Worst case: if n = 1 (deleting last node), both pointers move almost the whole list → O(N)
//   - Best case: if n = length (deleting head node), no second traversal → O(1)
//   - Overall: O(N)
// Space Complexity: O(1), only constant extra space is used.

var removeNthFromEnd = function(head, n) {
    let slow = head, fast = head;
    for(let i = 0; i < n; i++){
        fast = fast.next;
    }

    if(fast === null){
        return head.next;
    }

    while(fast !== null && fast.next !== null){
        slow = slow.next;
        fast = fast.next;
    }

    slow.next = slow.next.next;
    return head;
};
