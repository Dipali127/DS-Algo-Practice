// Leetcode Problem:
// brute force approach:-
// approach:-
// store all values of given linked list in array.
// call the checkPalindrome function on array to check that given linked list is palindrome or not.
// if array is palindrome means that given list is palindrome and return true otherwise return false.
// TC: O(N), Explanation:- 
// O(N) :- to store all linked list values in array.
// O(N) :- to check the linked list is palindrome or not.
// overall TC: O(N) + O(N) = O(2N) = O(N).
// SC: O(N), to store all linked list values in array.

 var isPalindrome = function(head){
    let arr = [];
    let temp = head;
     while(temp !== null){
        arr.push(temp.val);
        temp = temp.next;
     }

     return checkPalindrome(arr);
 }

//function use two pointer approach to check that given linked list is palidrome or not 
 function checkPalindrome(arr){
    let left = 0;
    let right = arr.length-1;
    while(left<right){
        if(arr[left] === arr[right]){
            left++;
            right--;
        }else{
            return false;
        }
    }

    return true;
 }

// optimal approach: using the Tortoise and Hare algorithm
// approach:
// find the middle of the linked list using slow and fast pointers.
//    - the slow pointer moves one step at a time.
//    - the fast pointer moves two steps at a time.
//    - when the fast pointer reaches the end, the slow pointer will be at the middle.
// 2. reverse the second half of the linked list starting from the middle node (from the slow pointer).
// 3. compare the first half of the linked list with the second half to check if the linked list is a palindrome.
// 4. reverse the second half of the list again to restore the original order of the linked list.
// TC: O(N)
// Explanation:
// - O(N/2) to find the middle of the linked list.
// - O(N/2) to reverse the second half of the linked list.
// - O(N/2) to compare both the first and second halves of the linked list to check for palindrome.
// - overall, TC: O(N/2) + O(N/2) + O(N/2) = O(3(N/2)) = O(N).
// SC: O(1), as only a few pointers are used, which take constant space.
  

var isPalindrome = function(head){
    let slow = head, fast = head;
    while(fast!== null && fast.next !== null){
        slow = slow.next;
        fast = fast.next.next;
    }

    let newHead = reverse(slow);
    let compare1 = head;
    let compare2 =  newHead;

    while(compare2 !== null){
        if(compare1.val !== compare2.val){
           reverse( newHead)
           return false;
        }else{
            compare1 = compare1.next;
            compare2 = compare2.next;
        }

    }
    reverse( newHead);
    return true;
}

function reverse(node){
    let prev = null;
    let current = node;
    let temp;
    while(current!= null){
        temp= current.next;
        current.next = prev;
        prev = current
        current = temp;
    }

    return prev;
}
